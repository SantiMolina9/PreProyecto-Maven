/*
  File Name: ycalc_ast.cup
  Parser modificado para generar AST en lugar de strings
  To Create: > java java_cup.Main < ycalc_ast.cup
*/

import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import ast.nodes.expression.*;
import ast.nodes.program.FunctionDefNode;
import ast.nodes.program.ParamNode;
import ast.nodes.program.ProgramNode;
import ast.nodes.statement.*;
import semantic.errors.ErrorHandler;

parser code {:
    private ErrorHandler errorHandler = ErrorHandler.getInstance();

    public void report_error(String message, Object info) {
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                int line = s.left + 1;
                int column = (s.right >= 0) ? s.right + 1 : 0;
                errorHandler.addSyntaxError(line, column, message);
                return;
            }
        }
        // Si no hay información de posición
        errorHandler.addSyntaxError(-1, -1, message);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

/* Terminal symbols (tokens) */
terminal           SEMI, COMMA, ASSIGN;
terminal           PLUS, MINUS, TIMES, DIVIDE;
terminal           LPAREN, RPAREN, LBRACE, RBRACE;
terminal           INT, BOOL, VOID, MAIN, RETURN;
terminal           TRUE, FALSE;
terminal           IF, ELSE, WHILE;
terminal           AND, OR, EQ, LT, GT, NOT;
terminal Integer   NUMBER;
terminal String    ID;

/* Non-terminal symbols - ahora retornan nodos del AST */
non terminal ProgramNode        program;
non terminal FunctionDefNode    function_def;
non terminal List               param_list, param_list_opt;
non terminal ParamNode          param;
non terminal String             type;
non terminal List               stmt_list;
non terminal StmtNode           stmt;
non terminal DeclarationNode    declaration;
non terminal AssignmentNode     assignment;
non terminal ReturnStmtNode     return_stmt;
non terminal ExprNode           expr;
non terminal List               var_list;
non terminal IfStmtNode         if_stmt;
non terminal WhileStmtNode      while_stmt;


/* Precedence */
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left OR;
precedence left AND;
precedence left EQ;
precedence left LT, GT;
precedence right NOT;

/* Grammar Rules */

program ::= function_def:f
            {:
                RESULT = new ProgramNode(fleft, fright, f);
            :}
            ;

function_def ::= type:t MAIN LPAREN param_list_opt:p RPAREN LBRACE stmt_list:s RBRACE
                 {:
                     List<ParamNode> params = (p != null) ? (List<ParamNode>)p : new ArrayList<ParamNode>();
                     List<StmtNode> statements = (List<StmtNode>)s;
                     RESULT = new FunctionDefNode(tleft, tright, t, "main", params, statements);
                 :}
                 ;

param_list_opt ::= param_list:p
                   {:  RESULT = p; :}
                   |
                   /* empty */
                   {:  RESULT = new ArrayList<ParamNode>(); :}
                   ;

param_list ::= param_list:pl COMMA param:p
               {:
                   List<ParamNode> list = (List<ParamNode>)pl;
                   list.add(p);
                   RESULT = list;
               :}
               |
               param:p
               {:
                   List<ParamNode> list = new ArrayList<ParamNode>();
                   list.add(p);
                   RESULT = list;
               :}
               ;

param ::= type:t ID:id
          {:
              RESULT = new ParamNode(tleft, tright, t, id);
          :}
          ;

type ::= INT
         {:  RESULT = "int"; :}
         |
         BOOL
         {:  RESULT = "bool"; :}
         |
         VOID
         {:  RESULT = "void"; :}
         ;

stmt_list ::= stmt_list:sl stmt:s
              {:
                  List<StmtNode> list = (List<StmtNode>)sl;
                  list.add(s);
                  RESULT = list;
              :}
              |
              stmt:s
              {:
                  List<StmtNode> list = new ArrayList<StmtNode>();
                  list.add(s);
                  RESULT = list;
              :}
              ;

stmt ::= declaration:d SEMI
         {:
             RESULT = d;
         :}
         |
         assignment:a SEMI
         {:
             RESULT = a;
         :}
         |
         return_stmt:r SEMI
         {:
             RESULT = r;
         :}
         |
         expr:e SEMI
         {:
             RESULT = new ExprStmtNode(eleft, eright, e);
         :}
         | if_stmt:stmts         {: RESULT = stmts; :}
         | while_stmt:stmts      {: RESULT = stmts; :}
         ;

if_stmt ::=
    IF:i LPAREN expr:cond RPAREN LBRACE stmt_list:then_stmts RBRACE
    {: RESULT = new IfStmtNode(ileft, iright, cond, then_stmts, null); :}
    | IF:i LPAREN expr:cond RPAREN LBRACE stmt_list:then_stmts RBRACE
      ELSE LBRACE stmt_list:else_stmts RBRACE
    {: RESULT = new IfStmtNode(ileft, iright, cond, then_stmts, else_stmts); :}
    ;

while_stmt ::=
    WHILE:w LPAREN expr:cond RPAREN LBRACE stmt_list:body RBRACE
    {: RESULT = new WhileStmtNode(wleft, wright, cond, body); :}
    ;

declaration ::= type:t var_list:vl
                {:
                    List<VarDeclNode> variables = (List<VarDeclNode>)vl;
                    RESULT = new DeclarationNode(tleft, tright, t, variables);
                :}
                ;

var_list ::= var_list:vl COMMA ID:id
             {:
                 List<VarDeclNode> list = (List<VarDeclNode>)vl;
                 list.add(new VarDeclNode(idleft, idright, id, null));
                 RESULT = list;
             :}
             |
             var_list:vl COMMA ID:id ASSIGN expr:e
             {:
                 List<VarDeclNode> list = (List<VarDeclNode>)vl;
                 list.add(new VarDeclNode(idleft, idright, id, e));
                 RESULT = list;
             :}
             |
             ID:id
             {:
                 List<VarDeclNode> list = new ArrayList<VarDeclNode>();
                 list.add(new VarDeclNode(idleft, idright, id, null));
                 RESULT = list;
             :}
             |
             ID:id ASSIGN expr:e
             {:
                 List<VarDeclNode> list = new ArrayList<VarDeclNode>();
                 list.add(new VarDeclNode(idleft, idright, id, e));
                 RESULT = list;
             :}
             ;

assignment ::= ID:id ASSIGN expr:e
               {:
                   RESULT = new AssignmentNode(idleft, idright, id, e);
               :}
               ;

return_stmt ::= RETURN:r expr:e
                {:
                    RESULT = new ReturnStmtNode(rleft, rright, e);
                :}
                |
                RETURN:r
                {:
                    RESULT = new ReturnStmtNode(rleft, rright, null);
                :}
                ;

expr ::= expr:e1 PLUS:op expr:e2
         {:
             RESULT = new BinaryOpNode(opleft, opright, e1, BinaryOpNode.Operator.PLUS, e2);
         :}
         |
         expr:e1 MINUS:op expr:e2
         {:
             RESULT = new BinaryOpNode(opleft, opright, e1, BinaryOpNode.Operator.MINUS, e2);
         :}
         |
         expr:e1 TIMES:op expr:e2
         {:
             RESULT = new BinaryOpNode(opleft, opright, e1, BinaryOpNode.Operator.TIMES, e2);
         :}
         |
         expr:e1 DIVIDE:op expr:e2
         {:
             RESULT = new BinaryOpNode(opleft, opright, e1, BinaryOpNode.Operator.DIVIDE, e2);
         :}
         |
         LPAREN expr:e RPAREN
         {:
             RESULT = e;
         :}
         |
         NUMBER:n
         {:
             RESULT = new NumberNode(nleft, nright, n);
         :}
         |
         TRUE:t
         {:
             RESULT = new BooleanNode(tleft, tright, true);
         :}
         |
         FALSE:f
         {:
             RESULT = new BooleanNode(fleft, fright, false);
         :}
         |
         ID:id
         {:
             RESULT = new VariableNode(idleft, idright, id);
         :}
         |
         expr:left AND:op expr:right
         {:
            RESULT = new BinaryOpNode(opleft, opright, left, BinaryOpNode.Operator.AND, right);
         :}
         |
         expr:left OR:op expr:right
         {:
            RESULT = new BinaryOpNode(opleft, opright, left, BinaryOpNode.Operator.OR, right);
         :}
         |
         expr:left EQ:op expr:right
         {:
            RESULT = new BinaryOpNode(opleft, opright, left, BinaryOpNode.Operator.EQ, right);
         :}
         |
         expr:left LT:op expr:right
         {:
            RESULT = new BinaryOpNode(opleft, opright, left, BinaryOpNode.Operator.LT, right);
         :}
         |
         expr:left GT:op expr:right
         {:
            RESULT = new BinaryOpNode(opleft, opright, left, BinaryOpNode.Operator.GT, right);
         :}
         |
         NOT:op expr:e
         {:
            RESULT = new UnaryOpNode(opleft, opright, UnaryOpNode.Operator.NOT, e);
         :}
         ;
